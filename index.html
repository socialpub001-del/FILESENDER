 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis AI - Holographic Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; z-index: 2; border: 2px solid cyan; border-radius: 10px; overflow: hidden; opacity: 0.7; }
        #input-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: cyan; text-shadow: 0 0 10px cyan; pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; letter-spacing: 2px; }
        #status { font-size: 14px; margin-top: 5px; color: #aaffaa; }
        #ai-response { 
            margin-top: 20px; font-size: 16px; width: 300px; 
            background: rgba(0, 20, 40, 0.6); padding: 15px; 
            border-left: 4px solid cyan; min-height: 50px;
        }

        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 20; display: flex; gap: 20px;
        }
        .btn {
            background: rgba(0, 255, 255, 0.1); border: 1px solid cyan; color: cyan;
            padding: 12px 24px; font-size: 16px; cursor: pointer; text-transform: uppercase;
            transition: all 0.3s; border-radius: 4px; box-shadow: 0 0 15px rgba(0,255,255,0.2);
        }
        .btn:hover { background: cyan; color: #000; box-shadow: 0 0 25px cyan; }
        .btn:active { transform: scale(0.95); }
        
        /* Arc Reactor Loader */
        .loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            border: 4px solid rgba(0,255,255,0.2); border-top: 4px solid cyan;
            border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite;
            z-index: 50; display: none;
        }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <div id="ui-layer">
        <h1>J.A.R.V.I.S. Core</h1>
        <div id="status">System: Waiting for initialization...</div>
        <div id="ai-response">"Waiting for command, Sir."</div>
    </div>

    <div class="loader" id="loading-spinner"></div>

    <div id="controls">
        <button class="btn" id="start-btn">Initialize System</button>
        <button class="btn" id="mic-btn" style="display:none;">Activate Voice</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_KEY = ""; // User provided key will be injected by environment if needed, but using the one from prompt for now
        // NOTE: In a real deployment, never hardcode API keys. For this demo, we use the user provided key.
        const USER_API_KEY = "AIzaSyDGWSwgFeiawRGXr5LTpKGemYfdQnWC7y4"; 
        const PARTICLE_COUNT = 3000;
        const PARTICLE_SIZE = 0.15;
        
        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, particleSystem;
        let targetPositions = []; // Where particles want to go
        let currentShape = 'sphere';
        
        // Hand Tracking Variables (Array for multiple hands)
        let handPositions = []; 
        let isPinching = false;
        
        // AI Context
        let conversationHistory = [
            { 
                role: "user", 
                parts: [{ 
                    text: `You are Jarvis, a holographic AI. 
                    CRITICAL INSTRUCTION: You MUST ALWAYS reply in strict JSON format. Do not use Markdown code blocks.
                    
                    Format: 
                    { 
                        "response": "Your spoken reply here (keep it witty and short)", 
                        "shape": "SHAPE_NAME", 
                        "color": "#HEXCODE" 
                    }
                    
                    Available Shapes: 'sphere', 'heart', 'butterfly', 'cube', 'galaxy', 'owl', 'dog', 'dna', 'pyramid'.
                    
                    If the user asks to change appearance, set the 'shape' field.
                    If the user speaks Hindi, reply in Hindi (Latin script) or Hinglish.
                    ` 
                }] 
            },
            { role: "model", parts: [{ text: "{\"response\": \"Online and ready, Sir.\", \"shape\": \"sphere\", \"color\": \"#00ffff\"}" }] }
        ];

        // --- THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Create Particles
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 20;
                colors[i] = 0.0; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom Shader Material
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            
            const material = new THREE.PointsMaterial({ 
                size: PARTICLE_SIZE, 
                map: sprite, 
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            // Initialize shape data
            calculateShapeTargets('sphere');
            
            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- SHAPE CALCULATIONS (MATH) ---
        function calculateShapeTargets(shapeName) {
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            currentShape = shapeName;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (shapeName === 'sphere') {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 8;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } 
                else if (shapeName === 'cube') {
                    const r = 6;
                    x = (Math.random() - 0.5) * 2 * r;
                    y = (Math.random() - 0.5) * 2 * r;
                    z = (Math.random() - 0.5) * 2 * r;
                    const maxVal = Math.max(Math.abs(x), Math.abs(y), Math.abs(z));
                    if(maxVal === Math.abs(x)) x = x > 0 ? r : -r;
                    else if(maxVal === Math.abs(y)) y = y > 0 ? r : -r;
                    else z = z > 0 ? r : -r;
                }
                else if (shapeName === 'pyramid') {
                     const h = 10;
                     const b = 8;
                     const t = Math.random();
                     const u = Math.random();
                     // Base
                     x = (t - 0.5) * b * (1-u);
                     z = (Math.random() - 0.5) * b * (1-u);
                     y = u * h - h/2;
                }
                else if (shapeName === 'heart') {
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    x = 16 * Math.pow(Math.sin(phi), 3);
                    y = 13 * Math.cos(phi) - 5 * Math.cos(2 * phi) - 2 * Math.cos(3 * phi) - Math.cos(4 * phi);
                    z = (Math.random()-0.5) * 2;
                    x *= 0.4; y *= 0.4;
                }
                else if (shapeName === 'butterfly') {
                    const t = Math.random() * 12 * Math.PI;
                    const c = Math.cos(t);
                    const s = Math.sin(t);
                    const r = Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t / 12), 5);
                    x = r * s * 3;
                    y = r * c * 3;
                    z = (Math.random() - 0.5) * 2 + (Math.sin(x) * 2);
                    y += 2; 
                }
                else if (shapeName === 'galaxy') {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 10;
                    const spiral = 2; 
                    x = Math.cos(angle * spiral + radius) * radius;
                    y = (Math.random() - 0.5) * 2;
                    z = Math.sin(angle * spiral + radius) * radius;
                }
                else if (shapeName === 'dna') {
                    const t = (i / PARTICLE_COUNT) * 10 * Math.PI;
                    x = Math.cos(t) * 4;
                    z = Math.sin(t) * 4;
                    y = (i / PARTICLE_COUNT) * 20 - 10;
                    if (Math.random() > 0.5) { x *= -1; z *= -1; } // Double helix
                }
                else if (shapeName === 'owl' || shapeName === 'dog') {
                    // Simplified blob shapes for animals
                    if (i < PARTICLE_COUNT * 0.3) {
                        const r = 3; 
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta) + 4;
                        z = r * Math.cos(phi);
                        if (shapeName === 'owl' && y > 6 && Math.abs(x) > 1.5) y += 1.5; // Ears
                    } else {
                        const r = 4.5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        x = r * Math.sin(phi) * Math.cos(theta) * 0.8;
                        y = r * Math.sin(phi) * Math.sin(theta) * 1.2 - 2;
                        z = r * Math.cos(phi) * 0.8;
                    }
                }
                else {
                     x = (Math.random() - 0.5) * 20;
                     y = (Math.random() - 0.5) * 20;
                     z = (Math.random() - 0.5) * 20;
                }

                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }

        function setParticleColor(hexColor) {
            const color = new THREE.Color(hexColor);
            const colors = particleSystem.geometry.attributes.color.array;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = particleSystem.geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                let tx = targetPositions[i3];
                let ty = targetPositions[i3 + 1];
                let tz = targetPositions[i3 + 2];

                // --- DUAL HAND INTERACTION ---
                // Loop through all detected hands and apply forces
                for (let h = 0; h < handPositions.length; h++) {
                    const hand = handPositions[h];
                    const dx = positions[i3] - hand.x;
                    const dy = positions[i3 + 1] - hand.y;
                    const dz = positions[i3 + 2] - hand.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist < 6) {
                        if (isPinching) {
                            // Implosion/Magnet effect if pinching
                            const force = 0.1;
                            tx = hand.x + (Math.random()-0.5) * 2;
                            ty = hand.y + (Math.random()-0.5) * 2;
                            tz = hand.z + (Math.random()-0.5) * 2;
                        } else {
                            // Repulsion effect (Push away)
                            const force = (6 - dist) * 0.8; 
                            tx += (dx / dist) * force;
                            ty += (dy / dist) * force;
                            tz += (dz / dist) * force;
                        }
                    }
                }

                // Lerp towards target
                positions[i3] += (tx - positions[i3]) * 0.05;
                positions[i3 + 1] += (ty - positions[i3 + 1]) * 0.05;
                positions[i3 + 2] += (tz - positions[i3 + 2]) * 0.05;
                
                // Idle movement
                positions[i3 + 1] += Math.sin(time + positions[i3]) * 0.005;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE HANDS SETUP ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2, // ENABLED 2 HANDS
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            // Reset hand positions for this frame
            handPositions = []; 
            isPinching = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                
                for (const landmarks of results.multiHandLandmarks) {
                    // Index Finger Tip (Landmark 8)
                    const x = (0.5 - landmarks[8].x) * 20; 
                    const y = (0.5 - landmarks[8].y) * 15; 
                    const z = landmarks[8].z * -10;
                    
                    handPositions.push(new THREE.Vector3(x, y, z));

                    // Check pinch on ANY hand
                    const dx = landmarks[4].x - landmarks[8].x;
                    const dy = landmarks[4].y - landmarks[8].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 0.05) isPinching = true;
                }
            }
        }

        // --- GEMINI AI & VOICE LOGIC ---
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;

            recognition.onstart = () => {
                document.getElementById('status').innerText = "Status: Listening...";
                document.getElementById('mic-btn').style.background = "red";
                document.getElementById('mic-btn').innerText = "Listening...";
            };

            recognition.onend = () => {
                document.getElementById('status').innerText = "Status: Processing...";
                document.getElementById('mic-btn').style.background = "rgba(0, 255, 255, 0.1)";
                document.getElementById('mic-btn').innerText = "Activate Voice";
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                document.getElementById('ai-response').innerHTML = `<strong>You:</strong> ${transcript}`;
                processAI(transcript);
            };
        } else {
            alert("Web Speech API not supported in this browser.");
        }

        async function processAI(userText) {
            document.getElementById('loading-spinner').style.display = 'block';
            conversationHistory.push({ role: "user", parts: [{ text: userText }] });

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${USER_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: conversationHistory,
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                const data = await response.json();
                let aiText = data.candidates[0].content.parts[0].text;
                
                // CLEANUP: Remove Markdown code blocks if present
                aiText = aiText.replace(/```json/g, '').replace(/```/g, '').trim();

                let aiJson = { response: "Processing error.", shape: currentShape };
                try {
                    aiJson = JSON.parse(aiText);
                } catch (e) {
                    console.error("JSON Parse Error", e);
                    // Attempt to extract JSON from text if mixed
                    const match = aiText.match(/\{[\s\S]*\}/);
                    if (match) {
                        try { aiJson = JSON.parse(match[0]); } catch (e2) {}
                    } else {
                         aiJson.response = aiText; // Fallback to plain text
                    }
                }

                conversationHistory.push({ role: "model", parts: [{ text: aiText }] });

                document.getElementById('ai-response').innerHTML = `<strong>Jarvis:</strong> ${aiJson.response}`;
                document.getElementById('status').innerText = "Status: Ready";
                document.getElementById('loading-spinner').style.display = 'none';

                // CHANGE SHAPE
                if (aiJson.shape && aiJson.shape !== currentShape) {
                    console.log("Changing shape to:", aiJson.shape);
                    calculateShapeTargets(aiJson.shape.toLowerCase());
                }
                
                // CHANGE COLOR
                if (aiJson.color) {
                    setParticleColor(aiJson.color);
                }

                speak(aiJson.response);

            } catch (error) {
                console.error("API Error:", error);
                document.getElementById('status').innerText = "Status: Connection Error";
                document.getElementById('loading-spinner').style.display = 'none';
            }
        }

        function speak(text) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name.includes("Google US English")) || voices[0];
            utterance.voice = preferredVoice;
            utterance.rate = 1.0;
            utterance.pitch = 0.9;
            window.speechSynthesis.speak(utterance);
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            initThree();
            initMediaPipe();
            setParticleColor('#00ffff');
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('mic-btn').style.display = 'block';
            document.getElementById('status').innerText = "Status: Online. Camera Active.";
            speak("Jarvis systems online. Hands tracking enabled.");
        });

        document.getElementById('mic-btn').addEventListener('click', () => {
            if (recognition) recognition.start();
        });

    </script>
</body>
</html>
